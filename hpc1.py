# -*- coding: utf-8 -*-
"""hpc1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1md015_wpcsSsnO5n53_I1UkxtfJsBV0f
"""

!nvcc --version

code ="""
#include<iostream>
#include<cuda.h>
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

#define N 32
using namespace std;

void init_rand(int *x)
{
  int i=0;
  for(i=0;i<N;i++)
  {
    x[i] = rand()%100;
    printf("%d \\n", x[i]);
  }
}

__global__ void add(int *x)
{
  int i = threadIdx.x;
  int n_threads = blockDim.x;
  int step = 1;
  while (n_threads>0)
  {
    if(i<n_threads)
    {
      int fi = i * step * 2;
      int si = fi + step;
      x[fi] += x[si];
    }
    step <<= 1;
    n_threads >>= 1;
  }
}

__global__ void min(int *x)
{
  int i = threadIdx.x;
  int step =1;
  int n_threads = blockDim.x;
  
  while (n_threads>0)
  {
    if(i<n_threads)
    {
      int fi = i*step*2;
      int si = fi+step;
      x[fi] = x[fi] < x[si] ? x[fi] : x[si];
    }
    step<<=1;
    n_threads>>=1;
  }
}

__global__ void max(int *x)
{
  int i = threadIdx.x;
  int step =1;
  int n_threads = blockDim.x;
  while (n_threads>0)
  {
    if(i<n_threads)
    {
      int fi = i * step * 2;
      int si = fi + step;
      x[fi] = x[fi] > x[si] ? x[fi] : x[si];
    }
    step<<=1;
    n_threads>>=1;
  }
}

int main()
{
  int *a;
  int *da;  
  int size = N * sizeof(int);
  int result;
  srand(time(0));
  
  a = (int*)malloc(size);
  cudaMalloc(&da,size);
  
  init_rand(a);
  cudaMemcpy(da,a,size,cudaMemcpyHostToDevice);
  
  add<<<1, N/2>>>(da);
  cudaMemcpy(&result,da,sizeof(int), cudaMemcpyDeviceToHost);
  printf("Sum %d", result);
  
  min<<<1,N/2>>>(da);
  cudaMemcpy(&result, da, sizeof(int), cudaMemcpyDeviceToHost);
  printf("Min %d ", result);
  
  max<<<1,N/2>>>(da);
  cudaMemcpy(&result, da, sizeof(int), cudaMemcpyDeviceToHost);
  printf("Max %d", result);
  
  cudaFree(da);
  return 0;
}
"""

file = open("hpc1.cu","w")
file.write(code)
file.close()

!nvcc hpc1.cu

!./a.out

!nvprof ./a.out